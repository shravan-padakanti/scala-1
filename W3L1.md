# Class Hierarchies
> **Static vs Dynamic Binding**
>
> In the most general terms, static binding means that references are resolved at compile time.
> ```java
> Animal a = new Animal();
> a.Roar(); // The compiler can resolve this method call statically.
> ```
> Dynamic binding means that references are resolved at run time.
> ```java
> public void MakeSomeNoise(object a) {
>  // Things happen...
>  ((Animal) a).Roar(); // You won't know if this works until runtime!
> }
> '''

For class hierarchies we will be taking the example of IntegerSets.

### Abstract Classes
These are the classes which are missing an implementation i.e just have the method signature. Consequently these classes cannot be instantiated using `new`.
```scala
abstract class IntSet{
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}
```

### Class Extension
Like in Java, classes and abstract classes can be extended by using the `extends` keyword.

Here we will implement the set as a **Binary Tree**. We maintain the _invariant_ that the nodes on the right hand side of any node have higher values than the nodes on the left hand side of that node. This will allow us to implement the contains method easily.
> A binary tree is made of nodes, where each node contains a "left" pointer, a "right" pointer, and a data element. The "root" pointer points to the topmost node in the tree.

An "empty" set can be implemented as below:
```scala
class Empty extends IntSet {
    def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
    def contains(x: Int): Boolean = false
}
```
A "non-empty" set can be implemented as below:
```scala
class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet {
    def contains(x: Int): Boolean =
        if (x < elem) left contains x
        else if (x > elem) right contains x
        else true

    def incl(x: Int): IntSet =
        if (x < elem) new NonEmpty(elem, left incl x, right)
        else if (x > elem) new NonEmpty(elem, left, right incl x)
        else this
        }
```

Thus here, the Empty and NonEmpty classes `extend` the class IntSet. This implies that the types Empty and NonEmpty conform to the type IntSet: an object of type Empty or NonEmpty can be used wherever an
object of type IntSet is required.

* IntSet is called the **superclass** of Empty and NonEmpty.
* Empty and NonEmpty are **subclasses** of IntSet.
* In Scala, any user-defined class extends another class. If no superclass is given, the standard class Object in the Java package `java.lang` is assumed.
* The direct or indirect superclasses of a class C are called **base classes** of C. So, the base classes of NonEmpty are IntSet and Object.