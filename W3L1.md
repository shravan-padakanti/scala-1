# Class Hierarchies
> **Static vs Dynamic Binding**
>
> In the most general terms, static binding means that references are resolved at compile time.
> ```java
> Animal a = new Animal();
> a.Roar(); // The compiler can resolve this method call statically.
> ```
> Dynamic binding means that references are resolved at run time.
> ```java
> public void MakeSomeNoise(object a) {
>  // Things happen...
>  ((Animal) a).Roar(); // You won't know if this works until runtime!
> }
> '''

### Abstract Classes
These are the classes which are missing an implementation i.e just have the method signature. Consequently these classes cannot be instantiated using `new`.
```scala
abstract class IntSet{
    def incl(x: Int): IntSet
    def contains(x: Int): Boolean
}
```

### Class Extension
Like in Java, classes and abstract classes can be extended by using the `extends` keyword.
```scala
class Empty extends IntSet {
    def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)
    def contains(x: Int): Boolean = false
}
```
> A binary tree is made of nodes, where each node contains a "left" pointer, a "right" pointer, and a data element. The "root" pointer points to the topmost node in the tree.<br/>
Here we have implemented the set as a Binary Tree. We maintain the _invariant_ that the nodes on the right hand side of any node have higher values than the nodes on the left hand side of that node.